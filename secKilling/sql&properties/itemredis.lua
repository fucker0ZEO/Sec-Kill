---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by fucker.
--- DateTime: 2021/4/18 0:43
---解决脏读的思路，get
---脏读更新不了的一个重要原因是，
---nginx查到应用服务器数据缓存之后，
---如果redis上发生了数据变更，
---但是应用服务器上，因为没有请求过来，应用服务器的数据就不会变化
---继而Nginx的数据也不变。
---又或者说，redis中的某个Key删了，
---但是应用服务器本地缓存的数据还没有过期
---Nginx的数据也没有过期/更新，这时用户读到的就是脏数据
---而加上这个自动检测并提醒机制，就多了一条更新方式，减少了脏读时间
---如果每次用户来请求，Nginx无论是否有数据都去读一次Redis
---redis中如果有数据就不变，
---redis中如果没有数据，Nginx就去请求应用服务器
---应用服务器就去让Redis更新数据，然后再更新到应用服务器中。
---应用服务器则同时收到redis中的更新数据
---
--- 拿到nginx接受的web请求的参数
local args = ngx.req.get_uri_args()
local id = args["id"]
-- 返回/引入的是resty目录下redis.lua这个脚本文件
local redis = require "resty.redis"
-- 新建一个redis的cache连接。
local cache = redis:new()
-- 通过内网IP+端口号 连接redis.返回的2个参数分别为ok，或者是erro
local ok,err = cache:connect("172.16.243.155",6379)
-- 根据id获取 value，就相当于调用redis中的 get命令
local item_model = cache:get("item_"..id)
-- 如果ngx为null，或者查redis的缓存为null
if item_model == ngx.null or item_model == nil then
    -- Nginx查redis，获取不到对应的值，就转发给所有的后端服务器
    -- 去找后端服务器去拿（也就相当于一种提醒），拿到后端的返回前端的结果（这个时候已经更新过了）
    local resp = ngx.location.capture("/item/get?id="..id)
    -- 返回z值赋给 item_model
    item_model = resp.body
end
-- 输出item_model,输出的是JSON
ngx.say(item_model)
